/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation } from '@tanstack/react-query'
import { customFetch } from '../../custom-fetch'
import type { ApiResponseGeminiEmbeddingResponse, ApiResponseVoid, DeleteUserByEmailParams } from '../refit-api.schemas'
import type { MutationFunction, QueryClient, UseMutationOptions, UseMutationResult } from '@tanstack/react-query'



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary (ÌÖåÏä§Ìä∏) ÏöîÏ≤≠ ÌÖçÏä§Ìä∏Ïùò ÏûÑÎ≤†Îî©Í∞íÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getGetGeminiEmbeddingUrl = () => {
  return `/test/user/test-embedding`
}

export const getGeminiEmbedding = async (
  getGeminiEmbeddingBody: string,
  options?: RequestInit,
): Promise<ApiResponseGeminiEmbeddingResponse> => {
  return customFetch<ApiResponseGeminiEmbeddingResponse>(getGetGeminiEmbeddingUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(getGeminiEmbeddingBody),
  })
}

export const getGetGeminiEmbeddingMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof getGeminiEmbedding>>, TError, { data: string }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof getGeminiEmbedding>>, TError, { data: string }, TContext> => {
  const mutationKey = ['getGeminiEmbedding']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getGeminiEmbedding>>, { data: string }> = (props) => {
    const { data } = props ?? {}

    return getGeminiEmbedding(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GetGeminiEmbeddingMutationResult = NonNullable<Awaited<ReturnType<typeof getGeminiEmbedding>>>
export type GetGeminiEmbeddingMutationBody = string
export type GetGeminiEmbeddingMutationError = unknown

/**
 * @summary (ÌÖåÏä§Ìä∏) ÏöîÏ≤≠ ÌÖçÏä§Ìä∏Ïùò ÏûÑÎ≤†Îî©Í∞íÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useGetGeminiEmbedding = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof getGeminiEmbedding>>, TError, { data: string }, TContext>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof getGeminiEmbedding>>, TError, { data: string }, TContext> => {
  return useMutation(getGetGeminiEmbeddingMutationOptions(options), queryClient)
}
export const getClusterCategoryUrl = () => {
  return `/test/batch/clustering-category`
}

export const clusterCategory = async (options?: RequestInit): Promise<void> => {
  return customFetch<void>(getClusterCategoryUrl(), {
    ...options,
    method: 'POST',
  })
}

export const getClusterCategoryMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof clusterCategory>>, TError, void, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof clusterCategory>>, TError, void, TContext> => {
  const mutationKey = ['clusterCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof clusterCategory>>, void> = () => {
    return clusterCategory(requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ClusterCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof clusterCategory>>>

export type ClusterCategoryMutationError = unknown

export const useClusterCategory = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof clusterCategory>>, TError, void, TContext>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof clusterCategory>>, TError, void, TContext> => {
  return useMutation(getClusterCategoryMutationOptions(options), queryClient)
}
/**
 * @summary (ÌÖåÏä§Ìä∏Ïö©) Ïú†Ï†ÄÎ•º Ïù¥Î©îÏùºÎ°ú Ï∞æÏïÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const getDeleteUserByEmailUrl = (params: DeleteUserByEmailParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/test/user?${stringifiedParams}` : `/test/user`
}

export const deleteUserByEmail = async (
  params: DeleteUserByEmailParams,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getDeleteUserByEmailUrl(params), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteUserByEmailMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserByEmail>>,
    TError,
    { params: DeleteUserByEmailParams },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUserByEmail>>,
  TError,
  { params: DeleteUserByEmailParams },
  TContext
> => {
  const mutationKey = ['deleteUserByEmail']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserByEmail>>,
    { params: DeleteUserByEmailParams }
  > = (props) => {
    const { params } = props ?? {}

    return deleteUserByEmail(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserByEmailMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserByEmail>>>

export type DeleteUserByEmailMutationError = unknown

/**
 * @summary (ÌÖåÏä§Ìä∏Ïö©) Ïú†Ï†ÄÎ•º Ïù¥Î©îÏùºÎ°ú Ï∞æÏïÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useDeleteUserByEmail = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUserByEmail>>,
      TError,
      { params: DeleteUserByEmailParams },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUserByEmail>>,
  TError,
  { params: DeleteUserByEmailParams },
  TContext
> => {
  return useMutation(getDeleteUserByEmailMutationOptions(options), queryClient)
}
/**
 * @summary (ÌÖåÏä§Ìä∏Ïö©) Ïú†Ï†ÄÎ•º idÎ°ú Ï∞æÏïÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const getDeleteUserByIdUrl = (userId: number) => {
  return `/test/user/${userId}`
}

export const deleteUserById = async (userId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getDeleteUserByIdUrl(userId), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteUserByIdMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserById>>, TError, { userId: number }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUserById>>, TError, { userId: number }, TContext> => {
  const mutationKey = ['deleteUserById']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserById>>, { userId: number }> = (props) => {
    const { userId } = props ?? {}

    return deleteUserById(userId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserById>>>

export type DeleteUserByIdMutationError = unknown

/**
 * @summary (ÌÖåÏä§Ìä∏Ïö©) Ïú†Ï†ÄÎ•º idÎ°ú Ï∞æÏïÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useDeleteUserById = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserById>>, TError, { userId: number }, TContext>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteUserById>>, TError, { userId: number }, TContext> => {
  return useMutation(getDeleteUserByIdMutationOptions(options), queryClient)
}
