/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import { customFetch } from '../../custom-fetch'
import type {
  ApiResponseGuideQuestionResponse,
  ApiResponseInterviewDto,
  ApiResponseInterviewFullDto,
  ApiResponseQnaSetCreateResponse,
  ApiResponseVoid,
  InterviewCreateRequest,
  InterviewResultStatusUpdateRequest,
  KptSelfReviewUpdateRequest,
  QnaSetCreateRequest,
  RawTextUpdateRequest,
} from '../refit-api.schemas'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query'



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ÏßàÎ¨∏, ÎãµÎ≥ÄÏúºÎ°ú Î≥ÄÌôòÎêòÍ∏∞ Ï†Ñ raw Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateRawTextUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text`
}

export const updateRawText = async (
  interviewId: number,
  rawTextUpdateRequest: RawTextUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateRawTextUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rawTextUpdateRequest),
  })
}

export const getUpdateRawTextMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRawText>>,
    TError,
    { interviewId: number; data: RawTextUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateRawText']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRawText>>,
    { interviewId: number; data: RawTextUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateRawText(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateRawTextMutationResult = NonNullable<Awaited<ReturnType<typeof updateRawText>>>
export type UpdateRawTextMutationBody = RawTextUpdateRequest
export type UpdateRawTextMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateRawText = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRawText>>,
      TError,
      { interviewId: number; data: RawTextUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateRawTextMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ëÏóê ÎåÄÌïú KPT ÌöåÍ≥†Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateKptSelfReviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}/kpt-self-review`
}

export const updateKptSelfReview = async (
  interviewId: number,
  kptSelfReviewUpdateRequest: KptSelfReviewUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateKptSelfReviewUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(kptSelfReviewUpdateRequest),
  })
}

export const getUpdateKptSelfReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    TError,
    { interviewId: number; data: KptSelfReviewUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateKptSelfReview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    { interviewId: number; data: KptSelfReviewUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateKptSelfReview(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateKptSelfReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateKptSelfReview>>>
export type UpdateKptSelfReviewMutationBody = KptSelfReviewUpdateRequest
export type UpdateKptSelfReviewMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏóê ÎåÄÌïú KPT ÌöåÍ≥†Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateKptSelfReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateKptSelfReview>>,
      TError,
      { interviewId: number; data: KptSelfReviewUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateKptSelfReviewMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getCreateInterviewUrl = () => {
  return `/interview`
}

export const createInterview = async (
  interviewCreateRequest: InterviewCreateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getCreateInterviewUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewCreateRequest),
  })
}

export const getCreateInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInterview>>,
    TError,
    { data: InterviewCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  const mutationKey = ['createInterview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInterview>>, { data: InterviewCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createInterview(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof createInterview>>>
export type CreateInterviewMutationBody = InterviewCreateRequest
export type CreateInterviewMutationError = unknown

/**
 * @summary Î©¥Ï†ë Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useCreateInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInterview>>,
      TError,
      { data: InterviewCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  return useMutation(getCreateInterviewMutationOptions(options), queryClient)
}
/**
 * @summary ÌäπÏ†ï Î©¥Ï†ëÏóê ÏÉàÎ°úÏö¥ ÏßàÎãµ ÏÑ∏Ìä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getCreateQnaSetUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-set`
}

export const createQnaSet = async (
  interviewId: number,
  qnaSetCreateRequest: QnaSetCreateRequest,
  options?: RequestInit,
): Promise<ApiResponseQnaSetCreateResponse> => {
  return customFetch<ApiResponseQnaSetCreateResponse>(getCreateQnaSetUrl(interviewId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(qnaSetCreateRequest),
  })
}

export const getCreateQnaSetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createQnaSet>>,
    TError,
    { interviewId: number; data: QnaSetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createQnaSet>>,
  TError,
  { interviewId: number; data: QnaSetCreateRequest },
  TContext
> => {
  const mutationKey = ['createQnaSet']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createQnaSet>>,
    { interviewId: number; data: QnaSetCreateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return createQnaSet(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateQnaSetMutationResult = NonNullable<Awaited<ReturnType<typeof createQnaSet>>>
export type CreateQnaSetMutationBody = QnaSetCreateRequest
export type CreateQnaSetMutationError = unknown

/**
 * @summary ÌäπÏ†ï Î©¥Ï†ëÏóê ÏÉàÎ°úÏö¥ ÏßàÎãµ ÏÑ∏Ìä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useCreateQnaSet = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createQnaSet>>,
      TError,
      { interviewId: number; data: QnaSetCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createQnaSet>>,
  TError,
  { interviewId: number; data: QnaSetCreateRequest },
  TContext
> => {
  return useMutation(getCreateQnaSetMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Í≤∞Í≥ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateInterviewResultStatusUrl = (interviewId: number) => {
  return `/interview/${interviewId}/result-status`
}

export const updateInterviewResultStatus = async (
  interviewId: number,
  interviewResultStatusUpdateRequest: InterviewResultStatusUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateInterviewResultStatusUrl(interviewId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewResultStatusUpdateRequest),
  })
}

export const getUpdateInterviewResultStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    TError,
    { interviewId: number; data: InterviewResultStatusUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateInterviewResultStatus']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    { interviewId: number; data: InterviewResultStatusUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateInterviewResultStatus(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInterviewResultStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>
>
export type UpdateInterviewResultStatusMutationBody = InterviewResultStatusUpdateRequest
export type UpdateInterviewResultStatusMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í≤∞Í≥ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateInterviewResultStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInterviewResultStatus>>,
      TError,
      { interviewId: number; data: InterviewResultStatusUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateInterviewResultStatusMutationOptions(options), queryClient)
}
/**
 * Î©¥Ï†ëÏóê ÎåÄÌïú Ï†ïÎ≥¥Îßå Ï°∞ÌöåÌïòÎ©∞, Î©¥Ï†ëÏóê ÏÜçÌïú ÏßàÎ¨∏, ÌöåÍ≥† Îì±Ïùò Ï†ïÎ≥¥Îäî Ï°∞ÌöåÌïòÏßÄ ÏïäÏäµÎãàÎã§.
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const getInterview = async (interviewId: number, options?: RequestInit): Promise<ApiResponseInterviewDto> => {
  return customFetch<ApiResponseInterviewDto>(getGetInterviewUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetInterviewQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}`] as const
}

export const getGetInterviewQueryOptions = <TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterview>>> = ({ signal }) =>
    getInterview(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewQueryResult = NonNullable<Awaited<ReturnType<typeof getInterview>>>
export type GetInterviewQueryError = unknown

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetInterviewSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterview>>> = ({ signal }) =>
    getInterview(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getInterview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInterview>>>
export type GetInterviewSuspenseQueryError = unknown

export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Î©¥Ï†ë ÏÇ≠Ï†úÏãú Ìï¥Îãπ Î©¥Ï†ëÏóê Í∏∞Î°ùÎêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò ÏÇ≠Ï†úÎê©ÎãàÎã§.
 * @summary Î©¥Ï†ëÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const getDeleteInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const deleteInterview = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getDeleteInterviewUrl(interviewId), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['deleteInterview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInterview>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return deleteInterview(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInterview>>>

export type DeleteInterviewMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useDeleteInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInterview>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getDeleteInterviewMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetInterviewFullUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-sets`
}

export const getInterviewFull = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponseInterviewFullDto> => {
  return customFetch<ApiResponseInterviewFullDto>(getGetInterviewFullUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetInterviewFullQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/qna-sets`] as const
}

export const getGetInterviewFullQueryOptions = <TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewFullQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterviewFull>>> = ({ signal }) =>
    getInterviewFull(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterviewFull>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewFullQueryResult = NonNullable<Awaited<ReturnType<typeof getInterviewFull>>>
export type GetInterviewFullQueryError = unknown

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewFullQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetInterviewFullSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterviewFull>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewFullQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterviewFull>>> = ({ signal }) =>
    getInterviewFull(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getInterviewFull>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewFullSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInterviewFull>>>
export type GetInterviewFullSuspenseQueryError = unknown

export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewFullSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetGuideQuestionUrl = (interviewId: number) => {
  return `/interview/${interviewId}/guide-question`
}

export const getGuideQuestion = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponseGuideQuestionResponse> => {
  return customFetch<ApiResponseGuideQuestionResponse>(getGetGuideQuestionUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetGuideQuestionQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/guide-question`] as const
}

export const getGetGuideQuestionQueryOptions = <TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGuideQuestionQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideQuestion>>> = ({ signal }) =>
    getGuideQuestion(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGuideQuestion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGuideQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideQuestion>>>
export type GetGuideQuestionQueryError = unknown

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGuideQuestionQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetGuideQuestionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGuideQuestion>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGuideQuestionQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideQuestion>>> = ({ signal }) =>
    getGuideQuestion(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGuideQuestion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGuideQuestionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideQuestion>>>
export type GetGuideQuestionSuspenseQueryError = unknown

export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGuideQuestionSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}
