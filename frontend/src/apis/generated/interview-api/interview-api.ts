/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import { customFetch } from '../../custom-fetch'
import type {
  ApiResponseConvertResultResponse,
  ApiResponseGuideQuestionResponse,
  ApiResponseInterviewCreateResponse,
  ApiResponseInterviewDto,
  ApiResponseInterviewFullDto,
  ApiResponsePdfFilePresignResponse,
  ApiResponseQnaSetCreateResponse,
  ApiResponseVoid,
  InterviewCreateRequest,
  InterviewResultStatusUpdateRequest,
  KptSelfReviewUpdateRequest,
  QnaSetCreateRequest,
  RawTextUpdateRequest,
} from '../refit-api.schemas'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query'



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * ÏßàÎ¨∏, ÎãµÎ≥ÄÏúºÎ°ú Î≥ÄÌôòÎêòÍ∏∞ Ï†Ñ raw Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateRawTextUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text`
}

export const updateRawText = async (
  interviewId: number,
  rawTextUpdateRequest: RawTextUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateRawTextUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rawTextUpdateRequest),
  })
}

export const getUpdateRawTextMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRawText>>,
    TError,
    { interviewId: number; data: RawTextUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateRawText']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRawText>>,
    { interviewId: number; data: RawTextUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateRawText(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateRawTextMutationResult = NonNullable<Awaited<ReturnType<typeof updateRawText>>>
export type UpdateRawTextMutationBody = RawTextUpdateRequest
export type UpdateRawTextMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateRawText = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRawText>>,
      TError,
      { interviewId: number; data: RawTextUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateRawTextMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ëÏóê ÎåÄÌïú KPT ÌöåÍ≥†Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateKptSelfReviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}/kpt-self-review`
}

export const updateKptSelfReview = async (
  interviewId: number,
  kptSelfReviewUpdateRequest: KptSelfReviewUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateKptSelfReviewUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(kptSelfReviewUpdateRequest),
  })
}

export const getUpdateKptSelfReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    TError,
    { interviewId: number; data: KptSelfReviewUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateKptSelfReview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    { interviewId: number; data: KptSelfReviewUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateKptSelfReview(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateKptSelfReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateKptSelfReview>>>
export type UpdateKptSelfReviewMutationBody = KptSelfReviewUpdateRequest
export type UpdateKptSelfReviewMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏóê ÎåÄÌïú KPT ÌöåÍ≥†Î•º ÏÉùÏÑ±/ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateKptSelfReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateKptSelfReview>>,
      TError,
      { interviewId: number; data: KptSelfReviewUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateKptSelfReviewMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const getCreateInterviewUrl = () => {
  return `/interview`
}

export const createInterview = async (
  interviewCreateRequest: InterviewCreateRequest,
  options?: RequestInit,
): Promise<ApiResponseInterviewCreateResponse> => {
  return customFetch<ApiResponseInterviewCreateResponse>(getCreateInterviewUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewCreateRequest),
  })
}

export const getCreateInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInterview>>,
    TError,
    { data: InterviewCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  const mutationKey = ['createInterview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInterview>>, { data: InterviewCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createInterview(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof createInterview>>>
export type CreateInterviewMutationBody = InterviewCreateRequest
export type CreateInterviewMutationError = unknown

/**
 * @summary Î©¥Ï†ë Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useCreateInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInterview>>,
      TError,
      { data: InterviewCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  return useMutation(getCreateInterviewMutationOptions(options), queryClient)
}
/**
 *         Î©¥Ï†ë ÏÉÅÌÉúÎ•º 'Í∏∞Î°ùÏ§ë' ÏÉÅÌÉúÎ°ú Î≥ÄÌôîÏãúÌÇµÎãàÎã§. Í∏∞Î°ùÏùÑ ÏôÑÎ£åÌïòÍ≥† ÏßàÎãµÏÑ∏Ìä∏Î°ú Í∏∞Î°ùÌïú ÎÇ¥Ïö©ÏùÑ Î≥ÄÌôò ÏöîÏ≤≠ÌïòÎ†§Î©¥ Î∞òÎìúÏãú Î©¥Ï†ë ÏÉÅÌÉúÍ∞Ä 'Í∏∞Î°ùÏ§ë' ÏÉÅÌÉúÏó¨Ïïº Ìï©ÎãàÎã§.

 * @summary Î©¥Ï†ë Í∏∞Î°ù ÎÖπÏùå/ÌÖçÏä§Ìä∏ ÏûëÏÑ±ÏùÑ ÏãúÏûëÌï©ÎãàÎã§.
 */
export const getStartLoggingUrl = (interviewId: number) => {
  return `/interview/${interviewId}/start-logging`
}

export const startLogging = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getStartLoggingUrl(interviewId), {
    ...options,
    method: 'POST',
  })
}

export const getStartLoggingMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof startLogging>>, TError, { interviewId: number }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof startLogging>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['startLogging']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof startLogging>>, { interviewId: number }> = (props) => {
    const { interviewId } = props ?? {}

    return startLogging(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type StartLoggingMutationResult = NonNullable<Awaited<ReturnType<typeof startLogging>>>

export type StartLoggingMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù ÎÖπÏùå/ÌÖçÏä§Ìä∏ ÏûëÏÑ±ÏùÑ ÏãúÏûëÌï©ÎãàÎã§.
 */
export const useStartLogging = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof startLogging>>, TError, { interviewId: number }, TContext>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof startLogging>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getStartLoggingMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ëÏùò ÌöåÍ≥† ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const getCompleteSelfReviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}/self-review/complete`
}

export const completeSelfReview = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getCompleteSelfReviewUrl(interviewId), {
    ...options,
    method: 'POST',
  })
}

export const getCompleteSelfReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeSelfReview>>,
    TError,
    { interviewId: number },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof completeSelfReview>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['completeSelfReview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSelfReview>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return completeSelfReview(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CompleteSelfReviewMutationResult = NonNullable<Awaited<ReturnType<typeof completeSelfReview>>>

export type CompleteSelfReviewMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏùò ÌöåÍ≥† ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const useCompleteSelfReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completeSelfReview>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof completeSelfReview>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getCompleteSelfReviewMutationOptions(options), queryClient)
}
/**
 *         Î≥ÄÌôòÏù¥ ÏôÑÎ£åÎêòÎ©¥ Î©¥Ï†ë ÏÉÅÌÉúÎ•º 'ÏßàÎãµ ÏÑ∏Ìä∏ Í≤ÄÌÜ†Ï§ë' ÏÉÅÌÉúÎ°ú Î∞îÍøâÎãàÎã§.
        ÏßàÎãµÏÑ∏Ìä∏Î•º Ï∂îÍ∞Ä/ÏàòÏ†ï/ÏÇ≠Ï†úÌïòÎ†§Î©¥ Î∞òÎìúÏãú Î©¥Ï†ë ÏÉÅÌÉúÍ∞Ä 'ÏßàÎãµ ÏÑ∏Ìä∏ Í≤ÄÌÜ†Ï§ë' ÏÉÅÌÉúÏó¨Ïïº Ìï©ÎãàÎã§.
        Î≥ÄÌôòÏù¥ Ïã§Ìå®ÌïòÎ©¥ Ïã§Ìå® ÏùëÎãµÏùÑ Î∞òÌôòÌïòÍ≥† 'Í∏∞Î°ù Ï§ë' ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌï©ÎãàÎã§.

 * @deprecated
 * @summary Î©¥Ï†ë Í∏∞Î°ùÏùÑ ÏßàÎ¨∏/ÎãµÎ≥Ä ÏÑ∏Ìä∏Î°ú Î≥ÄÌôòÌï©ÎãàÎã§.
 */
export const getConvertRawTextToQnaSetUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text/convert`
}

export const convertRawTextToQnaSet = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getConvertRawTextToQnaSetUrl(interviewId), {
    ...options,
    method: 'POST',
  })
}

export const getConvertRawTextToQnaSetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof convertRawTextToQnaSet>>,
    TError,
    { interviewId: number },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof convertRawTextToQnaSet>>,
  TError,
  { interviewId: number },
  TContext
> => {
  const mutationKey = ['convertRawTextToQnaSet']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof convertRawTextToQnaSet>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return convertRawTextToQnaSet(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConvertRawTextToQnaSetMutationResult = NonNullable<Awaited<ReturnType<typeof convertRawTextToQnaSet>>>

export type ConvertRawTextToQnaSetMutationError = unknown

/**
 * @deprecated
 * @summary Î©¥Ï†ë Í∏∞Î°ùÏùÑ ÏßàÎ¨∏/ÎãµÎ≥Ä ÏÑ∏Ìä∏Î°ú Î≥ÄÌôòÌï©ÎãàÎã§.
 */
export const useConvertRawTextToQnaSet = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof convertRawTextToQnaSet>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof convertRawTextToQnaSet>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getConvertRawTextToQnaSetMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Í∏∞Î°ùÏùÑ ÏßàÎ¨∏/ÎãµÎ≥Ä ÏÑ∏Ìä∏ÏúºÎ°ú Î≥ÄÌôò ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */
export const getRequestConvertUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text/convert/request`
}

export const requestConvert = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getRequestConvertUrl(interviewId), {
    ...options,
    method: 'POST',
  })
}

export const getRequestConvertMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof requestConvert>>, TError, { interviewId: number }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof requestConvert>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['requestConvert']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof requestConvert>>, { interviewId: number }> = (props) => {
    const { interviewId } = props ?? {}

    return requestConvert(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RequestConvertMutationResult = NonNullable<Awaited<ReturnType<typeof requestConvert>>>

export type RequestConvertMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ùÏùÑ ÏßàÎ¨∏/ÎãµÎ≥Ä ÏÑ∏Ìä∏ÏúºÎ°ú Î≥ÄÌôò ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */
export const useRequestConvert = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof requestConvert>>, TError, { interviewId: number }, TContext>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof requestConvert>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getRequestConvertMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ëÏóê ÏÉàÎ°úÏö¥ ÏßàÎãµ ÏÑ∏Ìä∏Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.
 */
export const getCreateQnaSetUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-set`
}

export const createQnaSet = async (
  interviewId: number,
  qnaSetCreateRequest: QnaSetCreateRequest,
  options?: RequestInit,
): Promise<ApiResponseQnaSetCreateResponse> => {
  return customFetch<ApiResponseQnaSetCreateResponse>(getCreateQnaSetUrl(interviewId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(qnaSetCreateRequest),
  })
}

export const getCreateQnaSetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createQnaSet>>,
    TError,
    { interviewId: number; data: QnaSetCreateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createQnaSet>>,
  TError,
  { interviewId: number; data: QnaSetCreateRequest },
  TContext
> => {
  const mutationKey = ['createQnaSet']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createQnaSet>>,
    { interviewId: number; data: QnaSetCreateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return createQnaSet(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateQnaSetMutationResult = NonNullable<Awaited<ReturnType<typeof createQnaSet>>>
export type CreateQnaSetMutationBody = QnaSetCreateRequest
export type CreateQnaSetMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏóê ÏÉàÎ°úÏö¥ ÏßàÎãµ ÏÑ∏Ìä∏Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.
 */
export const useCreateQnaSet = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createQnaSet>>,
      TError,
      { interviewId: number; data: QnaSetCreateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createQnaSet>>,
  TError,
  { interviewId: number; data: QnaSetCreateRequest },
  TContext
> => {
  return useMutation(getCreateQnaSetMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ëÏùò ÏßàÎãµ ÏÑ∏Ìä∏ ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const getCompleteQnaSetDraftUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-set/complete`
}

export const completeQnaSetDraft = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getCompleteQnaSetDraftUrl(interviewId), {
    ...options,
    method: 'POST',
  })
}

export const getCompleteQnaSetDraftMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeQnaSetDraft>>,
    TError,
    { interviewId: number },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof completeQnaSetDraft>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['completeQnaSetDraft']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeQnaSetDraft>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return completeQnaSetDraft(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CompleteQnaSetDraftMutationResult = NonNullable<Awaited<ReturnType<typeof completeQnaSetDraft>>>

export type CompleteQnaSetDraftMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏùò ÏßàÎãµ ÏÑ∏Ìä∏ ÏûëÏÑ±ÏùÑ ÏôÑÎ£åÌï©ÎãàÎã§.
 */
export const useCompleteQnaSetDraft = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completeQnaSetDraft>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof completeQnaSetDraft>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getCompleteQnaSetDraftMutationOptions(options), queryClient)
}
/**
 * @summary Î©¥Ï†ë Í≤∞Í≥ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const getUpdateInterviewResultStatusUrl = (interviewId: number) => {
  return `/interview/${interviewId}/result-status`
}

export const updateInterviewResultStatus = async (
  interviewId: number,
  interviewResultStatusUpdateRequest: InterviewResultStatusUpdateRequest,
  options?: RequestInit,
): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getUpdateInterviewResultStatusUrl(interviewId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewResultStatusUpdateRequest),
  })
}

export const getUpdateInterviewResultStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    TError,
    { interviewId: number; data: InterviewResultStatusUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateInterviewResultStatus']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    { interviewId: number; data: InterviewResultStatusUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateInterviewResultStatus(interviewId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInterviewResultStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>
>
export type UpdateInterviewResultStatusMutationBody = InterviewResultStatusUpdateRequest
export type UpdateInterviewResultStatusMutationError = unknown

/**
 * @summary Î©¥Ï†ë Í≤∞Í≥ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 */
export const useUpdateInterviewResultStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInterviewResultStatus>>,
      TError,
      { interviewId: number; data: InterviewResultStatusUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateInterviewResultStatusMutationOptions(options), queryClient)
}
/**
 * Î©¥Ï†ëÏóê ÎåÄÌïú Ï†ïÎ≥¥Îßå Ï°∞ÌöåÌïòÎ©∞, Î©¥Ï†ëÏóê ÏÜçÌïú ÏßàÎ¨∏, ÌöåÍ≥† Îì±Ïùò Ï†ïÎ≥¥Îäî Ï°∞ÌöåÌïòÏßÄ ÏïäÏäµÎãàÎã§.
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const getInterview = async (interviewId: number, options?: RequestInit): Promise<ApiResponseInterviewDto> => {
  return customFetch<ApiResponseInterviewDto>(getGetInterviewUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetInterviewQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}`] as const
}

export const getGetInterviewQueryOptions = <TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterview>>> = ({ signal }) =>
    getInterview(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewQueryResult = NonNullable<Awaited<ReturnType<typeof getInterview>>>
export type GetInterviewQueryError = unknown

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetInterviewSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterview>>> = ({ signal }) =>
    getInterview(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getInterview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInterview>>>
export type GetInterviewSuspenseQueryError = unknown

export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÌäπÏ†ï Î©¥Ï†ë Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewSuspense<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Î©¥Ï†ë ÏÇ≠Ï†úÏãú Ìï¥Îãπ Î©¥Ï†ëÏóê Í∏∞Î°ùÎêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò ÏÇ≠Ï†úÎê©ÎãàÎã§.
 * @summary Î©¥Ï†ëÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const getDeleteInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const deleteInterview = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getDeleteInterviewUrl(interviewId), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext>
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['deleteInterview']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInterview>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return deleteInterview(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInterview>>>

export type DeleteInterviewMutationError = unknown

/**
 * @summary Î©¥Ï†ëÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useDeleteInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInterview>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getDeleteInterviewMutationOptions(options), queryClient)
}
/**
 * @summary Î≥ÄÌôò ÏöîÏ≤≠ Í≤∞Í≥ºÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getWaitConvertResultUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text/convert/result`
}

export const waitConvertResult = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponseConvertResultResponse> => {
  return customFetch<ApiResponseConvertResultResponse>(getWaitConvertResultUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getWaitConvertResultQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/raw-text/convert/result`] as const
}

export const getWaitConvertResultQueryOptions = <
  TData = Awaited<ReturnType<typeof waitConvertResult>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getWaitConvertResultQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof waitConvertResult>>> = ({ signal }) =>
    waitConvertResult(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof waitConvertResult>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WaitConvertResultQueryResult = NonNullable<Awaited<ReturnType<typeof waitConvertResult>>>
export type WaitConvertResultQueryError = unknown

export function useWaitConvertResult<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof waitConvertResult>>,
          TError,
          Awaited<ReturnType<typeof waitConvertResult>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWaitConvertResult<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof waitConvertResult>>,
          TError,
          Awaited<ReturnType<typeof waitConvertResult>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWaitConvertResult<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î≥ÄÌôò ÏöîÏ≤≠ Í≤∞Í≥ºÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useWaitConvertResult<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getWaitConvertResultQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getWaitConvertResultSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof waitConvertResult>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getWaitConvertResultQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof waitConvertResult>>> = ({ signal }) =>
    waitConvertResult(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof waitConvertResult>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WaitConvertResultSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof waitConvertResult>>>
export type WaitConvertResultSuspenseQueryError = unknown

export function useWaitConvertResultSuspense<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWaitConvertResultSuspense<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWaitConvertResultSuspense<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î≥ÄÌôò ÏöîÏ≤≠ Í≤∞Í≥ºÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useWaitConvertResultSuspense<TData = Awaited<ReturnType<typeof waitConvertResult>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof waitConvertResult>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getWaitConvertResultSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetInterviewFullUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-sets`
}

export const getInterviewFull = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponseInterviewFullDto> => {
  return customFetch<ApiResponseInterviewFullDto>(getGetInterviewFullUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetInterviewFullQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/qna-sets`] as const
}

export const getGetInterviewFullQueryOptions = <TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewFullQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterviewFull>>> = ({ signal }) =>
    getInterviewFull(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterviewFull>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewFullQueryResult = NonNullable<Awaited<ReturnType<typeof getInterviewFull>>>
export type GetInterviewFullQueryError = unknown

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewFullQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetInterviewFullSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterviewFull>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewFullQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterviewFull>>> = ({ signal }) =>
    getInterviewFull(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getInterviewFull>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewFullSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getInterviewFull>>>
export type GetInterviewFullSuspenseQueryError = unknown

export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Î∞è Î©¥Ï†ëÏóê Í¥ÄÎ†®Îêú ÏßàÎ¨∏, ÌöåÍ≥† Îç∞Ïù¥ÌÑ∞Î•º Î™®Îëê Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetInterviewFullSuspense<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewFullSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */
export const getCreatePdfUploadUrlUrl = (interviewId: number) => {
  return `/interview/${interviewId}/pdf/upload-url`
}

export const createPdfUploadUrl = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponsePdfFilePresignResponse> => {
  return customFetch<ApiResponsePdfFilePresignResponse>(getCreatePdfUploadUrlUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getCreatePdfUploadUrlQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/pdf/upload-url`] as const
}

export const getCreatePdfUploadUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof createPdfUploadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCreatePdfUploadUrlQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof createPdfUploadUrl>>> = ({ signal }) =>
    createPdfUploadUrl(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof createPdfUploadUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreatePdfUploadUrlQueryResult = NonNullable<Awaited<ReturnType<typeof createPdfUploadUrl>>>
export type CreatePdfUploadUrlQueryError = unknown

export function useCreatePdfUploadUrl<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof createPdfUploadUrl>>,
          TError,
          Awaited<ReturnType<typeof createPdfUploadUrl>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfUploadUrl<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof createPdfUploadUrl>>,
          TError,
          Awaited<ReturnType<typeof createPdfUploadUrl>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfUploadUrl<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */

export function useCreatePdfUploadUrl<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCreatePdfUploadUrlQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getCreatePdfUploadUrlSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof createPdfUploadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCreatePdfUploadUrlQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof createPdfUploadUrl>>> = ({ signal }) =>
    createPdfUploadUrl(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof createPdfUploadUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreatePdfUploadUrlSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof createPdfUploadUrl>>>
export type CreatePdfUploadUrlSuspenseQueryError = unknown

export function useCreatePdfUploadUrlSuspense<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfUploadUrlSuspense<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfUploadUrlSuspense<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */

export function useCreatePdfUploadUrlSuspense<TData = Awaited<ReturnType<typeof createPdfUploadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfUploadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCreatePdfUploadUrlSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº Îã§Ïö¥Î°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */
export const getCreatePdfDownloadUrlUrl = (interviewId: number) => {
  return `/interview/${interviewId}/pdf/download-url`
}

export const createPdfDownloadUrl = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponsePdfFilePresignResponse> => {
  return customFetch<ApiResponsePdfFilePresignResponse>(getCreatePdfDownloadUrlUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getCreatePdfDownloadUrlQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/pdf/download-url`] as const
}

export const getCreatePdfDownloadUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCreatePdfDownloadUrlQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof createPdfDownloadUrl>>> = ({ signal }) =>
    createPdfDownloadUrl(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof createPdfDownloadUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreatePdfDownloadUrlQueryResult = NonNullable<Awaited<ReturnType<typeof createPdfDownloadUrl>>>
export type CreatePdfDownloadUrlQueryError = unknown

export function useCreatePdfDownloadUrl<TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof createPdfDownloadUrl>>,
          TError,
          Awaited<ReturnType<typeof createPdfDownloadUrl>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfDownloadUrl<TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof createPdfDownloadUrl>>,
          TError,
          Awaited<ReturnType<typeof createPdfDownloadUrl>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfDownloadUrl<TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº Îã§Ïö¥Î°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */

export function useCreatePdfDownloadUrl<TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCreatePdfDownloadUrlQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getCreatePdfDownloadUrlSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCreatePdfDownloadUrlQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof createPdfDownloadUrl>>> = ({ signal }) =>
    createPdfDownloadUrl(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof createPdfDownloadUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CreatePdfDownloadUrlSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof createPdfDownloadUrl>>>
export type CreatePdfDownloadUrlSuspenseQueryError = unknown

export function useCreatePdfDownloadUrlSuspense<
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfDownloadUrlSuspense<
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCreatePdfDownloadUrlSuspense<
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë PDF ÌååÏùº Îã§Ïö¥Î°úÎìúÎ•º ÏúÑÌïú Pre-Signed URLÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§.
 */

export function useCreatePdfDownloadUrlSuspense<
  TData = Awaited<ReturnType<typeof createPdfDownloadUrl>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof createPdfDownloadUrl>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCreatePdfDownloadUrlSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetGuideQuestionUrl = (interviewId: number) => {
  return `/interview/${interviewId}/guide-question`
}

export const getGuideQuestion = async (
  interviewId: number,
  options?: RequestInit,
): Promise<ApiResponseGuideQuestionResponse> => {
  return customFetch<ApiResponseGuideQuestionResponse>(getGetGuideQuestionUrl(interviewId), {
    ...options,
    method: 'GET',
  })
}

export const getGetGuideQuestionQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/guide-question`] as const
}

export const getGetGuideQuestionQueryOptions = <TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGuideQuestionQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideQuestion>>> = ({ signal }) =>
    getGuideQuestion(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGuideQuestion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGuideQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideQuestion>>>
export type GetGuideQuestionQueryError = unknown

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGuideQuestionQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export const getGetGuideQuestionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGuideQuestion>>,
  TError = unknown,
>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGuideQuestionQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideQuestion>>> = ({ signal }) =>
    getGuideQuestion(interviewId, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGuideQuestion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGuideQuestionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideQuestion>>>
export type GetGuideQuestionSuspenseQueryError = unknown

export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Î©¥Ï†ë Í∏∞Î°ù Ï§ë, Í∞ÄÏù¥Îìú ÏßàÎ¨∏ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetGuideQuestionSuspense<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGuideQuestionSuspenseQueryOptions(interviewId, options)

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Ïó∞Í¥ÄÎêú ÌïòÏù¥ÎùºÏù¥ÌåÖÏùÄ Î™®Îëê ÏÇ≠Ï†úÎê©ÎãàÎã§.

 * @summary Î©¥Ï†ë PDF ÌååÏùºÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const getDeleteInterviewPdfUrl = (interviewId: number) => {
  return `/interview/${interviewId}/pdf`
}

export const deleteInterviewPdf = async (interviewId: number, options?: RequestInit): Promise<ApiResponseVoid> => {
  return customFetch<ApiResponseVoid>(getDeleteInterviewPdfUrl(interviewId), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteInterviewPdfMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInterviewPdf>>,
    TError,
    { interviewId: number },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<Awaited<ReturnType<typeof deleteInterviewPdf>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['deleteInterviewPdf']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInterviewPdf>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return deleteInterviewPdf(interviewId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInterviewPdfMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInterviewPdf>>>

export type DeleteInterviewPdfMutationError = unknown

/**
 * @summary Î©¥Ï†ë PDF ÌååÏùºÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useDeleteInterviewPdf = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInterviewPdf>>,
      TError,
      { interviewId: number },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteInterviewPdf>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getDeleteInterviewPdfMutationOptions(options), queryClient)
}
