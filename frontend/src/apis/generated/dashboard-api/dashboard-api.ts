/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useQuery } from '@tanstack/react-query'
import { customFetch } from '../../custom-fetch'
import type {
  ApiResponseDashboardHeadlineResponse,
  ApiResponseListDashboardCalendarResponse,
  ApiResponsePageDashboardDebriefIncompletedInterviewResponse,
  ApiResponsePageDashboardMyDifficultQuestionResponse,
  ApiResponsePageDashboardUpcomingInterviewResponse,
  GetDashboardCalendarInterviewsParams,
  GetDebriefIncompletedInterviewsParams,
  GetMyDifficultQnaSetsParams,
  GetUpcomingInterviewsParams,
} from '../refit-api.schemas'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'ÎÇ¥Í∞Ä Ïñ¥Î†µÍ≤å ÎäêÎÇÄ ÏßàÎ¨∏'ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetMyDifficultQnaSetsUrl = (params: GetMyDifficultQnaSetsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/qna-set/my/difficult?${stringifiedParams}`
    : `/dashboard/qna-set/my/difficult`
}

export const getMyDifficultQnaSets = async (
  params: GetMyDifficultQnaSetsParams,
  options?: RequestInit,
): Promise<ApiResponsePageDashboardMyDifficultQuestionResponse> => {
  return customFetch<ApiResponsePageDashboardMyDifficultQuestionResponse>(getGetMyDifficultQnaSetsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetMyDifficultQnaSetsQueryKey = (params?: GetMyDifficultQnaSetsParams) => {
  return [`/dashboard/qna-set/my/difficult`, ...(params ? [params] : [])] as const
}

export const getGetMyDifficultQnaSetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
  TError = unknown,
>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetMyDifficultQnaSetsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyDifficultQnaSets>>> = ({ signal }) =>
    getMyDifficultQnaSets(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyDifficultQnaSetsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyDifficultQnaSets>>>
export type GetMyDifficultQnaSetsQueryError = unknown

export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
          TError,
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
          TError,
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'ÎÇ¥Í∞Ä Ïñ¥Î†µÍ≤å ÎäêÎÇÄ ÏßàÎ¨∏'ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyDifficultQnaSetsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Í≥ß Î≥¥Í≤åÎêòÎäî Î©¥Ï†ë Ï†ïÎ≥¥, Ïú†ÏÇ¨ ÏÇ∞ÏóÖÍµ∞/ÏßÅÍµ∞ Î©¥Ï†ë ÏßàÎ¨∏, Ïú†ÏÇ¨ Î©¥Ï†ë Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
Í∞Å Î©¥Ï†ë ÏùºÏ†ïÏùò Dday ÌïÑÎìúÎäî Í≥ºÍ±∞ÎùºÎ©¥ ÏùåÏàò, ÎØ∏ÎûòÎùºÎ©¥ ÏñëÏàò Í∞íÏùÑ Í∞ñÏäµÎãàÎã§.

 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'Í≥ß ÏûàÏùÑ Î©¥Ï†ë' ÏòÅÏó≠Ïùò Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetUpcomingInterviewsUrl = (params: GetUpcomingInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/interview/upcoming?${stringifiedParams}`
    : `/dashboard/interview/upcoming`
}

export const getUpcomingInterviews = async (
  params: GetUpcomingInterviewsParams,
  options?: RequestInit,
): Promise<ApiResponsePageDashboardUpcomingInterviewResponse> => {
  return customFetch<ApiResponsePageDashboardUpcomingInterviewResponse>(getGetUpcomingInterviewsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetUpcomingInterviewsQueryKey = (params?: GetUpcomingInterviewsParams) => {
  return [`/dashboard/interview/upcoming`, ...(params ? [params] : [])] as const
}

export const getGetUpcomingInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpcomingInterviews>>,
  TError = unknown,
>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUpcomingInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingInterviews>>> = ({ signal }) =>
    getUpcomingInterviews(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpcomingInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUpcomingInterviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingInterviews>>>
export type GetUpcomingInterviewsQueryError = unknown

export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingInterviews>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingInterviews>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'Í≥ß ÏûàÏùÑ Î©¥Ï†ë' ÏòÅÏó≠Ïùò Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUpcomingInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú Î≥µÍ∏∞ ÎåÄÍ∏∞Ï§ëÏù∏ Î©¥Ï†ë Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetDebriefIncompletedInterviewsUrl = (params: GetDebriefIncompletedInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/interview/debrief-uncompleted?${stringifiedParams}`
    : `/dashboard/interview/debrief-uncompleted`
}

export const getDebriefIncompletedInterviews = async (
  params: GetDebriefIncompletedInterviewsParams,
  options?: RequestInit,
): Promise<ApiResponsePageDashboardDebriefIncompletedInterviewResponse> => {
  return customFetch<ApiResponsePageDashboardDebriefIncompletedInterviewResponse>(
    getGetDebriefIncompletedInterviewsUrl(params),
    {
      ...options,
      method: 'GET',
    },
  )
}

export const getGetDebriefIncompletedInterviewsQueryKey = (params?: GetDebriefIncompletedInterviewsParams) => {
  return [`/dashboard/interview/debrief-uncompleted`, ...(params ? [params] : [])] as const
}

export const getGetDebriefIncompletedInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDebriefIncompletedInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>> = ({ signal }) =>
    getDebriefIncompletedInterviews(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDebriefIncompletedInterviewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
>
export type GetDebriefIncompletedInterviewsQueryError = unknown

export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú Î≥µÍ∏∞ ÎåÄÍ∏∞Ï§ëÏù∏ Î©¥Ï†ë Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDebriefIncompletedInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * ÎåÄÏãúÎ≥¥Îìú Ìó§ÎìúÎùºÏù∏ ÌÉÄÏûÖÍ≥º, Ìï¥Îãπ ÌÉÄÏûÖÏóêÏÑú ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞Î•º ÏùëÎãµÌï©ÎãàÎã§.
Ìó§ÎìúÎùºÏù∏ ÌÉÄÏûÖÏóêÎäî Îã§ÏùåÏùò 4Í∞ÄÏßÄ ÌÉÄÏûÖÏù¥ ÏùëÎãµÏúºÎ°ú ÎÇòÏòµÎãàÎã§.
#0 "REGISTER_INTERVIEW" - Î©¥Ï†ë ÏùºÏ†ï Îì±Î°ùÌïòÍ∏∞ (ÏïÑÏßÅ Î©¥Ï†ë ÏùºÏ†ïÏù¥ ÏóÜÎäî Í≤ΩÏö∞, Ï¥àÍ∏∞ ÏÇ¨Ïö©Ïûê)
#1 "PREPARE_INTERVIEW"  - Î©¥Ï†ë ÎåÄÎπÑÌïòÍ∏∞ (ÏùºÏ£ºÏùº ÎÇ¥ ÏòàÏ†ïÎêú Î©¥Ï†ë ÏùºÏ†ïÏù¥ ÏûàÎäî Í≤ΩÏö∞)
#2 "REVIEW_INTERVIEW"   - Î©¥Ï†ë Î≥µÍ∏∞ ÏãúÏûëÌïòÍ∏∞ (Î≥µÍ∏∞Î•º ÏôÑÎ£åÌïòÏßÄ ÏïäÏùÄ Î©¥Ï†ëÏù¥ Ï°¥Ïû¨ÌïòÎäî Í≤ΩÏö∞)
#3 "CHECK_INTERVIEW_HISTORY" - Î©¥Ï†ë ÌûàÏä§ÌÜ† ÌôïÏù∏ÌïòÍ∏∞ (ÏúÑ ÏºÄÏù¥Ïä§Ïóê Ìï¥ÎãπÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞)

 * @summary ÎåÄÏãúÎ≥¥Îìú Ìó§ÎìúÎùºÏù∏Ïóê Îì§Ïñ¥Í∞à Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetDashboardHeadlineUrl = () => {
  return `/dashboard/headline`
}

export const getDashboardHeadline = async (options?: RequestInit): Promise<ApiResponseDashboardHeadlineResponse> => {
  return customFetch<ApiResponseDashboardHeadlineResponse>(getGetDashboardHeadlineUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetDashboardHeadlineQueryKey = () => {
  return [`/dashboard/headline`] as const
}

export const getGetDashboardHeadlineQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardHeadline>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
  request?: SecondParameter<typeof customFetch>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDashboardHeadlineQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardHeadline>>> = ({ signal }) =>
    getDashboardHeadline({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardHeadline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardHeadlineQueryResult = NonNullable<Awaited<ReturnType<typeof getDashboardHeadline>>>
export type GetDashboardHeadlineQueryError = unknown

export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardHeadline>>,
          TError,
          Awaited<ReturnType<typeof getDashboardHeadline>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardHeadline>>,
          TError,
          Awaited<ReturnType<typeof getDashboardHeadline>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ìó§ÎìúÎùºÏù∏Ïóê Îì§Ïñ¥Í∞à Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardHeadlineQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Î©¥Ï†ë ÏùºÏ†ïÏù¥ Ï°¥Ïû¨ÌïòÎäî date Î¶¨Ïä§Ìä∏, Í∞Å date Î≥ÑÎ°úÎäî Ìï¥Îãπ date Ïóê Ï°¥Ïû¨ÌïòÎäî Î©¥Ï†ë ÏùºÏ†ï Î¶¨Ïä§Ìä∏Í∞Ä Ï°∞ÌöåÎê©ÎãàÎã§.
date Î¶¨Ïä§Ìä∏Îäî ÎÇ†ÏßúÏàúÏúºÎ°ú Ï†ïÎ†¨, Í∞Å date Î≥Ñ Ìï¥Îãπ date Ïóê Ï°¥Ïû¨ÌïòÎäî Î©¥Ï†ë ÏùºÏ†ïÎì§ÏùÄ ÏãúÍ∞ÑÏàúÏúºÎ°ú Ï†ïÎ†¨ÎêòÏñ¥ Ï°∞ÌöåÎê©ÎãàÎã§.
Í∞Å Î©¥Ï†ë ÏùºÏ†ïÏùò Dday ÌïÑÎìúÎäî Í≥ºÍ±∞ÎùºÎ©¥ ÏùåÏàò, ÎØ∏ÎûòÎùºÎ©¥ ÏñëÏàò Í∞íÏùÑ Í∞ñÏäµÎãàÎã§.

 * @summary ÎåÄÏãúÎ≥¥Îìú Ï∫òÎ¶∞ÎçîÏóê Îì±Î°ùÎêú Î©¥Ï†ë ÏùºÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getGetDashboardCalendarInterviewsUrl = (params: GetDashboardCalendarInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/calendar/interview?${stringifiedParams}`
    : `/dashboard/calendar/interview`
}

export const getDashboardCalendarInterviews = async (
  params: GetDashboardCalendarInterviewsParams,
  options?: RequestInit,
): Promise<ApiResponseListDashboardCalendarResponse> => {
  return customFetch<ApiResponseListDashboardCalendarResponse>(getGetDashboardCalendarInterviewsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetDashboardCalendarInterviewsQueryKey = (params?: GetDashboardCalendarInterviewsParams) => {
  return [`/dashboard/calendar/interview`, ...(params ? [params] : [])] as const
}

export const getGetDashboardCalendarInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDashboardCalendarInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>> = ({ signal }) =>
    getDashboardCalendarInterviews(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardCalendarInterviewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
>
export type GetDashboardCalendarInterviewsQueryError = unknown

export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ï∫òÎ¶∞ÎçîÏóê Îì±Î°ùÎêú Î©¥Ï†ë ÏùºÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardCalendarInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}
