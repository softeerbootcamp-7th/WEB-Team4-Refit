/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useQuery } from '@tanstack/react-query'
import type {
  GetDashboardCalendarInterviewsParams,
  GetDebriefIncompletedInterviewsParams,
  GetMyDifficultQnaSetsParams,
  GetUpcomingInterviewsParams,
} from '../refit-api.schemas'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'


/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'ÎÇ¥Í∞Ä Ïñ¥Î†µÍ≤å ÎäêÎÇÄ ÏßàÎ¨∏'ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export type getMyDifficultQnaSetsResponse200 = {
  data: Blob
  status: 200
}

export type getMyDifficultQnaSetsResponseSuccess = getMyDifficultQnaSetsResponse200 & {
  headers: Headers
}
export type getMyDifficultQnaSetsResponse = getMyDifficultQnaSetsResponseSuccess

export const getGetMyDifficultQnaSetsUrl = (params: GetMyDifficultQnaSetsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/qna-set/my/difficult?${stringifiedParams}`
    : `/dashboard/qna-set/my/difficult`
}

export const getMyDifficultQnaSets = async (
  params: GetMyDifficultQnaSetsParams,
  options?: RequestInit,
): Promise<getMyDifficultQnaSetsResponse> => {
  const res = await fetch(getGetMyDifficultQnaSetsUrl(params), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getMyDifficultQnaSetsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getMyDifficultQnaSetsResponse
}

export const getGetMyDifficultQnaSetsQueryKey = (params?: GetMyDifficultQnaSetsParams) => {
  return [`/dashboard/qna-set/my/difficult`, ...(params ? [params] : [])] as const
}

export const getGetMyDifficultQnaSetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
  TError = unknown,
>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetMyDifficultQnaSetsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyDifficultQnaSets>>> = ({ signal }) =>
    getMyDifficultQnaSets(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyDifficultQnaSetsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyDifficultQnaSets>>>
export type GetMyDifficultQnaSetsQueryError = unknown

export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
          TError,
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>,
          TError,
          Awaited<ReturnType<typeof getMyDifficultQnaSets>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'ÎÇ¥Í∞Ä Ïñ¥Î†µÍ≤å ÎäêÎÇÄ ÏßàÎ¨∏'ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetMyDifficultQnaSets<TData = Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError = unknown>(
  params: GetMyDifficultQnaSetsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyDifficultQnaSets>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyDifficultQnaSetsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'Í≥ß ÏûàÏùÑ Î©¥Ï†ë' ÏòÅÏó≠Ïùò Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export type getUpcomingInterviewsResponse200 = {
  data: Blob
  status: 200
}

export type getUpcomingInterviewsResponseSuccess = getUpcomingInterviewsResponse200 & {
  headers: Headers
}
export type getUpcomingInterviewsResponse = getUpcomingInterviewsResponseSuccess

export const getGetUpcomingInterviewsUrl = (params: GetUpcomingInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/interview/upcoming?${stringifiedParams}`
    : `/dashboard/interview/upcoming`
}

export const getUpcomingInterviews = async (
  params: GetUpcomingInterviewsParams,
  options?: RequestInit,
): Promise<getUpcomingInterviewsResponse> => {
  const res = await fetch(getGetUpcomingInterviewsUrl(params), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getUpcomingInterviewsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUpcomingInterviewsResponse
}

export const getGetUpcomingInterviewsQueryKey = (params?: GetUpcomingInterviewsParams) => {
  return [`/dashboard/interview/upcoming`, ...(params ? [params] : [])] as const
}

export const getGetUpcomingInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpcomingInterviews>>,
  TError = unknown,
>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUpcomingInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingInterviews>>> = ({ signal }) =>
    getUpcomingInterviews(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpcomingInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUpcomingInterviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingInterviews>>>
export type GetUpcomingInterviewsQueryError = unknown

export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingInterviews>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingInterviews>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú 'Í≥ß ÏûàÏùÑ Î©¥Ï†ë' ÏòÅÏó≠Ïùò Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetUpcomingInterviews<TData = Awaited<ReturnType<typeof getUpcomingInterviews>>, TError = unknown>(
  params: GetUpcomingInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUpcomingInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú Î≥µÍ∏∞ ÎåÄÍ∏∞Ï§ëÏù∏ Î©¥Ï†ë Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export type getDebriefIncompletedInterviewsResponse200 = {
  data: Blob
  status: 200
}

export type getDebriefIncompletedInterviewsResponseSuccess = getDebriefIncompletedInterviewsResponse200 & {
  headers: Headers
}
export type getDebriefIncompletedInterviewsResponse = getDebriefIncompletedInterviewsResponseSuccess

export const getGetDebriefIncompletedInterviewsUrl = (params: GetDebriefIncompletedInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/interview/debrief-uncompleted?${stringifiedParams}`
    : `/dashboard/interview/debrief-uncompleted`
}

export const getDebriefIncompletedInterviews = async (
  params: GetDebriefIncompletedInterviewsParams,
  options?: RequestInit,
): Promise<getDebriefIncompletedInterviewsResponse> => {
  const res = await fetch(getGetDebriefIncompletedInterviewsUrl(params), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getDebriefIncompletedInterviewsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDebriefIncompletedInterviewsResponse
}

export const getGetDebriefIncompletedInterviewsQueryKey = (params?: GetDebriefIncompletedInterviewsParams) => {
  return [`/dashboard/interview/debrief-uncompleted`, ...(params ? [params] : [])] as const
}

export const getGetDebriefIncompletedInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDebriefIncompletedInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>> = ({ signal }) =>
    getDebriefIncompletedInterviews(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDebriefIncompletedInterviewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
>
export type GetDebriefIncompletedInterviewsQueryError = unknown

export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú Î≥µÍ∏∞ ÎåÄÍ∏∞Ï§ëÏù∏ Î©¥Ï†ë Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDebriefIncompletedInterviews<
  TData = Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>,
  TError = unknown,
>(
  params: GetDebriefIncompletedInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDebriefIncompletedInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDebriefIncompletedInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ìó§ÎìúÎùºÏù∏Ïóê Îì§Ïñ¥Í∞à Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export type getDashboardHeadlineResponse200 = {
  data: Blob
  status: 200
}

export type getDashboardHeadlineResponseSuccess = getDashboardHeadlineResponse200 & {
  headers: Headers
}
export type getDashboardHeadlineResponse = getDashboardHeadlineResponseSuccess

export const getGetDashboardHeadlineUrl = () => {
  return `/dashboard/headline`
}

export const getDashboardHeadline = async (options?: RequestInit): Promise<getDashboardHeadlineResponse> => {
  const res = await fetch(getGetDashboardHeadlineUrl(), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getDashboardHeadlineResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDashboardHeadlineResponse
}

export const getGetDashboardHeadlineQueryKey = () => {
  return [`/dashboard/headline`] as const
}

export const getGetDashboardHeadlineQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardHeadline>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
  fetch?: RequestInit
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDashboardHeadlineQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardHeadline>>> = ({ signal }) =>
    getDashboardHeadline({ signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardHeadline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardHeadlineQueryResult = NonNullable<Awaited<ReturnType<typeof getDashboardHeadline>>>
export type GetDashboardHeadlineQueryError = unknown

export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardHeadline>>,
          TError,
          Awaited<ReturnType<typeof getDashboardHeadline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardHeadline>>,
          TError,
          Awaited<ReturnType<typeof getDashboardHeadline>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ìó§ÎìúÎùºÏù∏Ïóê Îì§Ïñ¥Í∞à Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDashboardHeadline<TData = Awaited<ReturnType<typeof getDashboardHeadline>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardHeadline>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardHeadlineQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ï∫òÎ¶∞ÎçîÏóê Îì±Î°ùÎêú Î©¥Ï†ë ÏùºÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export type getDashboardCalendarInterviewsResponse200 = {
  data: Blob
  status: 200
}

export type getDashboardCalendarInterviewsResponseSuccess = getDashboardCalendarInterviewsResponse200 & {
  headers: Headers
}
export type getDashboardCalendarInterviewsResponse = getDashboardCalendarInterviewsResponseSuccess

export const getGetDashboardCalendarInterviewsUrl = (params: GetDashboardCalendarInterviewsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/dashboard/calendar/interview?${stringifiedParams}`
    : `/dashboard/calendar/interview`
}

export const getDashboardCalendarInterviews = async (
  params: GetDashboardCalendarInterviewsParams,
  options?: RequestInit,
): Promise<getDashboardCalendarInterviewsResponse> => {
  const res = await fetch(getGetDashboardCalendarInterviewsUrl(params), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getDashboardCalendarInterviewsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDashboardCalendarInterviewsResponse
}

export const getGetDashboardCalendarInterviewsQueryKey = (params?: GetDashboardCalendarInterviewsParams) => {
  return [`/dashboard/calendar/interview`, ...(params ? [params] : [])] as const
}

export const getGetDashboardCalendarInterviewsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDashboardCalendarInterviewsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>> = ({ signal }) =>
    getDashboardCalendarInterviews(params, { signal, ...fetchOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardCalendarInterviewsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
>
export type GetDashboardCalendarInterviewsQueryError = unknown

export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
          TError,
          Awaited<ReturnType<typeof getDashboardCalendarInterviews>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÎåÄÏãúÎ≥¥Îìú Ï∫òÎ¶∞ÎçîÏóê Îì±Î°ùÎêú Î©¥Ï†ë ÏùºÏ†ïÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetDashboardCalendarInterviews<
  TData = Awaited<ReturnType<typeof getDashboardCalendarInterviews>>,
  TError = unknown,
>(
  params: GetDashboardCalendarInterviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardCalendarInterviews>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardCalendarInterviewsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}
