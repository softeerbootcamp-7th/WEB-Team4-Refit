/**
 * Generated by orval v8.1.0 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  InterviewCreateRequest,
  InterviewResultStatusUpdateRequest,
  KptSelfReviewUpdateRequest,
  RawTextUpdateRequest,
} from '../refit-api.schemas'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'


export type updateRawTextResponse200 = {
  data: Blob
  status: 200
}

export type updateRawTextResponseSuccess = updateRawTextResponse200 & {
  headers: Headers
}
export type updateRawTextResponse = updateRawTextResponseSuccess

export const getUpdateRawTextUrl = (interviewId: number) => {
  return `/interview/${interviewId}/raw-text`
}

export const updateRawText = async (
  interviewId: number,
  rawTextUpdateRequest: RawTextUpdateRequest,
  options?: RequestInit,
): Promise<updateRawTextResponse> => {
  const res = await fetch(getUpdateRawTextUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rawTextUpdateRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: updateRawTextResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateRawTextResponse
}

export const getUpdateRawTextMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRawText>>,
    TError,
    { interviewId: number; data: RawTextUpdateRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateRawText']
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRawText>>,
    { interviewId: number; data: RawTextUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateRawText(interviewId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateRawTextMutationResult = NonNullable<Awaited<ReturnType<typeof updateRawText>>>
export type UpdateRawTextMutationBody = RawTextUpdateRequest
export type UpdateRawTextMutationError = unknown

export const useUpdateRawText = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRawText>>,
      TError,
      { interviewId: number; data: RawTextUpdateRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRawText>>,
  TError,
  { interviewId: number; data: RawTextUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateRawTextMutationOptions(options), queryClient)
}
export type updateKptSelfReviewResponse200 = {
  data: Blob
  status: 200
}

export type updateKptSelfReviewResponseSuccess = updateKptSelfReviewResponse200 & {
  headers: Headers
}
export type updateKptSelfReviewResponse = updateKptSelfReviewResponseSuccess

export const getUpdateKptSelfReviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}/kpt-self-review`
}

export const updateKptSelfReview = async (
  interviewId: number,
  kptSelfReviewUpdateRequest: KptSelfReviewUpdateRequest,
  options?: RequestInit,
): Promise<updateKptSelfReviewResponse> => {
  const res = await fetch(getUpdateKptSelfReviewUrl(interviewId), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(kptSelfReviewUpdateRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: updateKptSelfReviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateKptSelfReviewResponse
}

export const getUpdateKptSelfReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    TError,
    { interviewId: number; data: KptSelfReviewUpdateRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateKptSelfReview']
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateKptSelfReview>>,
    { interviewId: number; data: KptSelfReviewUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateKptSelfReview(interviewId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateKptSelfReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateKptSelfReview>>>
export type UpdateKptSelfReviewMutationBody = KptSelfReviewUpdateRequest
export type UpdateKptSelfReviewMutationError = unknown

export const useUpdateKptSelfReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateKptSelfReview>>,
      TError,
      { interviewId: number; data: KptSelfReviewUpdateRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateKptSelfReview>>,
  TError,
  { interviewId: number; data: KptSelfReviewUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateKptSelfReviewMutationOptions(options), queryClient)
}
export type createInterviewResponse200 = {
  data: Blob
  status: 200
}

export type createInterviewResponseSuccess = createInterviewResponse200 & {
  headers: Headers
}
export type createInterviewResponse = createInterviewResponseSuccess

export const getCreateInterviewUrl = () => {
  return `/interview`
}

export const createInterview = async (
  interviewCreateRequest: InterviewCreateRequest,
  options?: RequestInit,
): Promise<createInterviewResponse> => {
  const res = await fetch(getCreateInterviewUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewCreateRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: createInterviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createInterviewResponse
}

export const getCreateInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInterview>>,
    TError,
    { data: InterviewCreateRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  const mutationKey = ['createInterview']
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createInterview>>, { data: InterviewCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return createInterview(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof createInterview>>>
export type CreateInterviewMutationBody = InterviewCreateRequest
export type CreateInterviewMutationError = unknown

export const useCreateInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInterview>>,
      TError,
      { data: InterviewCreateRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createInterview>>,
  TError,
  { data: InterviewCreateRequest },
  TContext
> => {
  return useMutation(getCreateInterviewMutationOptions(options), queryClient)
}
export type updateInterviewResultStatusResponse200 = {
  data: Blob
  status: 200
}

export type updateInterviewResultStatusResponseSuccess = updateInterviewResultStatusResponse200 & {
  headers: Headers
}
export type updateInterviewResultStatusResponse = updateInterviewResultStatusResponseSuccess

export const getUpdateInterviewResultStatusUrl = (interviewId: number) => {
  return `/interview/${interviewId}/result-status`
}

export const updateInterviewResultStatus = async (
  interviewId: number,
  interviewResultStatusUpdateRequest: InterviewResultStatusUpdateRequest,
  options?: RequestInit,
): Promise<updateInterviewResultStatusResponse> => {
  const res = await fetch(getUpdateInterviewResultStatusUrl(interviewId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(interviewResultStatusUpdateRequest),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: updateInterviewResultStatusResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateInterviewResultStatusResponse
}

export const getUpdateInterviewResultStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    TError,
    { interviewId: number; data: InterviewResultStatusUpdateRequest },
    TContext
  >
  fetch?: RequestInit
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateInterviewResultStatus']
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInterviewResultStatus>>,
    { interviewId: number; data: InterviewResultStatusUpdateRequest }
  > = (props) => {
    const { interviewId, data } = props ?? {}

    return updateInterviewResultStatus(interviewId, data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInterviewResultStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>
>
export type UpdateInterviewResultStatusMutationBody = InterviewResultStatusUpdateRequest
export type UpdateInterviewResultStatusMutationError = unknown

export const useUpdateInterviewResultStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInterviewResultStatus>>,
      TError,
      { interviewId: number; data: InterviewResultStatusUpdateRequest },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInterviewResultStatus>>,
  TError,
  { interviewId: number; data: InterviewResultStatusUpdateRequest },
  TContext
> => {
  return useMutation(getUpdateInterviewResultStatusMutationOptions(options), queryClient)
}
export type getInterviewResponse200 = {
  data: Blob
  status: 200
}

export type getInterviewResponseSuccess = getInterviewResponse200 & {
  headers: Headers
}
export type getInterviewResponse = getInterviewResponseSuccess

export const getGetInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const getInterview = async (interviewId: number, options?: RequestInit): Promise<getInterviewResponse> => {
  const res = await fetch(getGetInterviewUrl(interviewId), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getInterviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInterviewResponse
}

export const getGetInterviewQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}`] as const
}

export const getGetInterviewQueryOptions = <TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterview>>> = ({ signal }) =>
    getInterview(interviewId, { signal, ...fetchOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewQueryResult = NonNullable<Awaited<ReturnType<typeof getInterview>>>
export type GetInterviewQueryError = unknown

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterview>>,
          TError,
          Awaited<ReturnType<typeof getInterview>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetInterview<TData = Awaited<ReturnType<typeof getInterview>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterview>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export type deleteInterviewResponse200 = {
  data: Blob
  status: 200
}

export type deleteInterviewResponseSuccess = deleteInterviewResponse200 & {
  headers: Headers
}
export type deleteInterviewResponse = deleteInterviewResponseSuccess

export const getDeleteInterviewUrl = (interviewId: number) => {
  return `/interview/${interviewId}`
}

export const deleteInterview = async (interviewId: number, options?: RequestInit): Promise<deleteInterviewResponse> => {
  const res = await fetch(getDeleteInterviewUrl(interviewId), {
    ...options,
    method: 'DELETE',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: deleteInterviewResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteInterviewResponse
}

export const getDeleteInterviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext>
  fetch?: RequestInit
}): UseMutationOptions<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  const mutationKey = ['deleteInterview']
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteInterview>>, { interviewId: number }> = (
    props,
  ) => {
    const { interviewId } = props ?? {}

    return deleteInterview(interviewId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInterviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteInterview>>>

export type DeleteInterviewMutationError = unknown

export const useDeleteInterview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInterview>>,
      TError,
      { interviewId: number },
      TContext
    >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteInterview>>, TError, { interviewId: number }, TContext> => {
  return useMutation(getDeleteInterviewMutationOptions(options), queryClient)
}
export type getInterviewFullResponse200 = {
  data: Blob
  status: 200
}

export type getInterviewFullResponseSuccess = getInterviewFullResponse200 & {
  headers: Headers
}
export type getInterviewFullResponse = getInterviewFullResponseSuccess

export const getGetInterviewFullUrl = (interviewId: number) => {
  return `/interview/${interviewId}/qna-sets`
}

export const getInterviewFull = async (
  interviewId: number,
  options?: RequestInit,
): Promise<getInterviewFullResponse> => {
  const res = await fetch(getGetInterviewFullUrl(interviewId), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getInterviewFullResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInterviewFullResponse
}

export const getGetInterviewFullQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/qna-sets`] as const
}

export const getGetInterviewFullQueryOptions = <TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterviewFullQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInterviewFull>>> = ({ signal }) =>
    getInterviewFull(interviewId, { signal, ...fetchOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterviewFull>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInterviewFullQueryResult = NonNullable<Awaited<ReturnType<typeof getInterviewFull>>>
export type GetInterviewFullQueryError = unknown

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewFull>>,
          TError,
          Awaited<ReturnType<typeof getInterviewFull>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetInterviewFull<TData = Awaited<ReturnType<typeof getInterviewFull>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInterviewFull>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInterviewFullQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

export type getGuideQuestionResponse200 = {
  data: Blob
  status: 200
}

export type getGuideQuestionResponseSuccess = getGuideQuestionResponse200 & {
  headers: Headers
}
export type getGuideQuestionResponse = getGuideQuestionResponseSuccess

export const getGetGuideQuestionUrl = (interviewId: number) => {
  return `/interview/${interviewId}/guide-question`
}

export const getGuideQuestion = async (
  interviewId: number,
  options?: RequestInit,
): Promise<getGuideQuestionResponse> => {
  const res = await fetch(getGetGuideQuestionUrl(interviewId), {
    ...options,
    method: 'GET',
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()

  const data: getGuideQuestionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getGuideQuestionResponse
}

export const getGetGuideQuestionQueryKey = (interviewId: number) => {
  return [`/interview/${interviewId}/guide-question`] as const
}

export const getGetGuideQuestionQueryOptions = <TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    fetch?: RequestInit
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGuideQuestionQueryKey(interviewId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGuideQuestion>>> = ({ signal }) =>
    getGuideQuestion(interviewId, { signal, ...fetchOptions })

  return { queryKey, queryFn, enabled: !!interviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGuideQuestion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGuideQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof getGuideQuestion>>>
export type GetGuideQuestionQueryError = unknown

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGuideQuestion>>,
          TError,
          Awaited<ReturnType<typeof getGuideQuestion>>
        >,
        'initialData'
      >
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGuideQuestion<TData = Awaited<ReturnType<typeof getGuideQuestion>>, TError = unknown>(
  interviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGuideQuestion>>, TError, TData>>
    fetch?: RequestInit
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGuideQuestionQueryOptions(interviewId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}
